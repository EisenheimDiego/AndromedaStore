# Course README 5/6/24

## Objective
The objective of this course is for students to develop an online store using React and Next.js for the frontend, and ASP.NET Core for the REST API.

## Prerequisites
To follow this course, you need to be familiar with these Git commands: git branch, git add, git commit, git push, in order to create a PR (Pull Request). Provide an example of each Git command.

To effectively follow this course, it is essential to have a basic understanding of Git and be familiar with the following commands:

- `git branch`: This command is used to list, create, or delete branches. To create a branch based on master ```git branch -b topic1```
- `git add`: This command is used to stage changes for the next commit. ```git add file.txt```
- `git commit`: This command is used to record changes to the repository. ```git commit -m "Added new feature"```
- `git push`: This command is used to upload local repository content to a remote repository.```git push origin topic1```

## React 
For the React part, we will utilize the following components and hooks:
- Components
```jsx
import React from 'react';

const ExampleComponent = () => {
  return (
    <div>
      <h1>This is an example component</h1>
      <p>It demonstrates the basic structure of a React component.</p>
    </div>
  );
};

export default ExampleComponent;
```
- The use of prompts.
```jsx
import React from 'react';

const PromptComponent = () => {
  const handleClick = () => {
    const userInput = prompt('Enter your name:');
    alert(`Hello, ${userInput}!`);
  };

  return (
    <div>
      <button onClick={handleClick}>Prompt</button>
    </div>
  );
};

export default PromptComponent;

```
- useState Hook:Tthe useState hook for managing component state. https://react.dev/reference/react/useState
```jsx
import React, { useState } from 'react';

const StateExample = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default StateExample;
```
- useEffect: The useEffect hook for handling side effects. https://react.dev/reference/react/useEffect
```jsx
import React, { useState, useEffect } from 'react';

const EffectExample = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Clicked ${count} times`;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default EffectExample;
```
## ASP core .Net
For the development of the REST API, ASP.NET Core will be used, where each controller will interact with React's fetch. To do this, it is necessary to understand .NET Controllers, for example, variable visibility, for example, what is in the bin folder, where configurations are placed, for example

NET Controllers: In ASP.NET Core, controllers are classes that handle incoming HTTP requests, execute the appropriate logic, and return an HTTP response. They are responsible for processing client requests and generating the corresponding responses. Here's an example of a simple controller in C#:

```C#
using Microsoft.AspNetCore.Mvc;

[Route("api/[controller]")]
[ApiController]
public class ExampleController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        return Ok("This is a GET request response");
    }

    [HttpPost]
    public IActionResult Post([FromBody] string value)
    {
        return Ok($"Received POST request with value: {value}");
    }
}
```
Variable Visibility: In .NET, the visibility of variables determines where they can be accessed from within a program. There are several access modifiers in C#:

- public: The variable is accessible from any other code in the same assembly or project.
- private: The variable is only accessible within the class in which it is declared.
- protected: The variable is accessible within the class in which it is declared and any derived classes.
- internal: The variable is accessible within the same assembly, but not from other assemblies.
- protected internal: The variable is accessible within the same assembly and from derived classes in other assemblies.
Example:
```
public class ExampleClass
{
    public int publicVariable; // Public variable accessible from anywhere
    private int privateVariable; // Private variable accessible only within this class
    protected int protectedVariable; // Protected variable accessible within this class and derived classes
    internal int internalVariable; // Internal variable accessible within the same assembly
    protected internal int protectedInternalVariable; // Accessible within the same assembly and from derived classes in other assemblies
}
```
Contents of the bin folder: The bin folder in a .NET project contains binary files generated by the compilation process. These files include executable files, DLLs (Dynamic Link Libraries), and other compiled artifacts. It also contains temporary files and artifacts created during the build process. The contents of the bin folder are typically automatically generated and managed by the build tools, and it's not recommended to modify them manually.

Configuration Placement: In ASP.NET Core, configuration settings are typically stored in JSON files (e.g., appsettings.json) or environment variables. These configuration files contain settings such as connection strings, API keys, and application-specific settings. They are usually placed in the project's root directory or in a dedicated Configs or Settings folder. Here's an example of an appsettings.json file:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"
  }
}
```

## How to debug 
You can also refer to this helpful video tutorial for further guidance: [Debugging ASP.NET and React Web Projects](https://youtu.be/vyjWkqiEwHc)

###  React front-end application
For this part, we will use the `debugger` statement to instruct the browser where it should pause execution. Then, we will use the browser's controls to navigate through different flows of the React code.

```jsx
import React from 'react';

class ExampleComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  handleClick = () => {
    // Increment count when the button is clicked
    this.setState(prevState => ({
      count: prevState.count + 1
    }));

    // Inserting a debugger to pause execution and inspect variables
    debugger;
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}

export default ExampleComponent;
```
In the example above, the debugger statement is inserted inside the handleClick method of a React component. This means that when the button is clicked and the handleClick method is called, the execution of the code will pause at the debugger statement, allowing developers to inspect the current state of the component, props, or any other variables in scope.

###  ASP core REST API
For this part, we will configure the Visual Studio Code Debugger to set a breakpoint and examine the code execution on the backend.
The steps to debug an ASP.NET Web project are as follows:
1. Create the `launch.json` file. To do this, go to the "Run and Debug" option and click on "Create launch.json file".
2. Select C#.
3. Click on "Add Configuration".
4. Look for the option ".NET: Launch Executable file (Web)".
5. Finally, fix the URL and the name of the DLL.


## Code reviews and Feedback
[Code review - React useEffec, ASP Core  and feedback](https://youtu.be/V4lnIGXlRFs)


